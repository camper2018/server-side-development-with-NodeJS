JavaScript, when it is first designed was meant to be a scripting language to be used within the browser.
Now JavaScript has gone way beyond its original intention, and is being used for writing applications, both to be run using frameworks within the browser,
and also to run applications on the server side.
JavaScript originally was never designed with any common libraries.
If you look at standard programming languages like C, C++, Java, and so on,
they all have standard libraries that enable you to access the underlying hardware.
And also provide a structured way of organization the application into multiple files and then combining them together when you create an application.
JavaScript never had any of this support when it began.
But of course, people understood the difficulties when you need to expand JavaScript beyond a single file which is used as a scripting language for the browser.
Now, if you have a very large JavaScript application, it becomes cumbersome to write the entire code in one single file.
And obviously you want the results to be able to break your application into multiple facts.
Unlike traditional programming languages, JavaScript never had a way of distributing the code into multiple files and then combining them together.
So this is where the CommonJS API came in to fill in this gap that fills in the needs for some common application.
And this CommonJS format defines a module format that can be used for breaking up your JavaScript application into multiple files.
Node adopts that CommonJS format for organizing our JavaScript application into multiple files.
And within JavaScript, with the CommonJS format, each file becomes its own Node module.
So within that file, the CommonJS specification provides a variable called the module variable which is a JavaScript object.
And this gives you access to the current module definition within a file.
And on this module object, you have the module.exports property which determines the export from the current module.
So when you assign something to the module.exports property, then that becomes the exported value from the current module.
So that when this module is imported into another file of our Node application, then whatever is exported from this module becomes available in the second application.
When you need to import a module into another module, this is where the require function is used to import the module.
Node modules can be of three kinds:
1. We have file-based Node modules where we define the Node module within a file, within our application and we make use of it within our application.
2. We have core Node modules that are already part of Node.
The Node designers kept these core modules intentionally small so that Node can be kept small.
And also provide sufficient functionality so that external module designers can add in their own functionality that can be leveraged when we developed Node applications.
So the core modules include path, file system (fs), os, util, and a few others.
3. Then we have external Node modules.
These are third-party Node modules that are developed by Node developers, and then made available through the Node ecosystem.
So these external Node modules can be install within our system using NPM.

Package.json is a Menifest file for our app. It is a file that contains information about the files in our app i.e metadata eg: name, version, liscence, author, modules used etc
With node, we have the option of using JavaScript or Typescript as a language.
The documentation for node and also express, all use standard JavaScript as a default. So we will be using standard JavaScript in this course or ES2015 JavaScript in this course.
If we prefer to use TypeScript, we can set up our node examples to write our application in TypeScript.
But then we will have to transpile that code into JavaScript so that it can be run using Node.
So we have to set up additional infrastructure in order to be able to use TypeScript.
Asynchronous execution and Callbacks:
Before we proceed on to talk about Node Modules and Callbacks, we need to understand two salient features about the JavaScript language itself.
First and foremost, JavaScript supports what is called as first-class functions.
Is that a function can be treated just like any other variable.
And hence, functions can be passed around as parameters inside function calls to other functions.
And that essentially allows us to send in functions as callback functions that can be called from another Node module in order to get some work accomplished.
Then look at how this is very useful in supporting callbacks in Node.js
The second aspect about JavaScript is the support for Closures.
A function defined inside another function automatically gets access to the variables that are declared in the outer function. So even if the outer function is completed execution, when the inner function executes later the inner function will still have access to the values of the variables within that outer function.
And this is again, very effectively used when we use Callbacks in Node applications.

HTTP VERBS:
Http is a client-server communication protocol.
Get, Post, Put, Delete, Head, Options, Trace, Connect.

Intro To Express:
The Node designers intentionally kept node small with a small number of code modules so that they can leave it up to third party developers to come up with innovative solutions to problems.
One of the most popular third party Node modules or frameworks for building HTTP servers is Express.
Express is a fast, unopinionated, minimalist framework that runs on top of Node.js and supports Web development.
Express also provides a way of extending and adding functionality to Express through third-party middleware.
To use Express in your project, of course, the first step is to install Express and since Express is a Node module, we install it by saying npm install express --save and this would install Express into your local project.
The middleware that Express supports provide a lot of plug-in functionality that would be used to enhance your Express application,
plug-in functionality like for example we will look at a middleware called Morgan which allows you to print out log information to the screen about the requests that come into your server.
Similarly, we'll look at another middleware called BodyParser, which allows you to parse the body of the incoming HTTP request message and extract information from it for use within your Express application.
Similarly, they can serve up static Web resources from our server using the express.static so this will serve up information from a folder within our Express project,
and in declaring the project we can say __filename and __dirname which gives you the full path for the file or the directory for the current module.
Brief Tour of a Node Module:
Examine a Package.json file and look at semantic versioning.
So when you specify the version of the package that you use, you always specify the version by specifying the Major Version.Minor Version.the patch.
So when you install a package, it is always identified by these three numbers:
major version which might introduce breaking changes so which means that if you are installing a newer version of package it may not be completely backward compatible with previous versions.
It may introduce breaking changes whereby you may need to go back and fix the code that you might have written in the earlier version of your project.
The minor version introduces some minor changes to your package and may not be breaking changes.
A patch would be a bug fix that is often issued when a small bug is discovered.
So patches usually do not lead to any breaking changes and so you can easily use a higher version or a higher patch version of a particular package that you're using within your Node application.
With npm install, we can specifiy the acceptable package version as follows:
1.Exact: means exact version match : npm install express@4.0.0
2.Patch acceptable: npm install express@"~4.0.0"
3.Minor version acceptable:npm install express@"^4.0.0"
This kind of information is also saved in the package.json file.
The third-party modules and their version info is stored in package.json file in as dependencies.

Package.lock.json file:
This is being installed by the newer versions of npm.
The package-lock.json file is automatically generated by npm which stores information about the exact tree that was generated when you install other Node modules
and this is very useful when you need to do installation of the Node modules at another location.
So for example if you download a Git repository and try to recreate this project on another computer, you would simply type npm install on the prompt and that'll prompt your Node application to automatically install everything that is specified in the dependencies here for you.
While creating that the package-lock.json stores additional information that is used by npm to do the correct installation of all the npm modules that are required.

Exercise (Instructions): Introduction to Express:
In this exercise you learnt to use the Express framework to design and implement a web server.
a.A Simple Server using Express:
1.Create a folder named node-express in the NodeJS folder and move to that folder.
2.Copy the public folder from node-http to this folder.
3.At the prompt, type the following to initialize a package.json file in the node-express folder:
npm init
4.Accept the standard defaults suggested until you end up with a package.json file as we have in folder.
5.Then, install the Express framework in the folder by typing the following at the prompt:
  npm install express@4.16.3 --save
6.Create a file named .gitignore and add the following to it:
  node_modules
7.Create a file named index.js and add the code to it as seen in commit "Express Example".
8.Start the server by typing the following at the prompt, and then interact with the server:
  npm start
9.Initialize a Git repository, add the files and do a Git commit with the message "Express Example".

b.Serving Static Files:
1.Install morgan by typing the following at the prompt. Morgan is used for logging purposes:
  npm install morgan@1.9.0 --save
2.Update index.js to include it.
3.Start the server and interact with it and observe the behavior.
4.Do a Git commit with the message "Express Serve Static Files".

REST:
Web Services are a way of designing systems to support interoperability among systems that are connected over a network like the internet as we see today.
This is what we refer to as a service-oriented architecture.
Now, what this means is that you provide a standardized way for two machines that are connected to the internet to be able to communicate with each other at the application layer level for web-based applications using open standards.
Two common approaches that are used for supporting web services are:
1. SOAP: The Simple Object Access Protocol based web services which uses the web services description language for specifying how the two endpoints communicate with each other.
Typically SOAP is based on using XML as the format for the messages being exchanged between the two endpoints.
2.Representational State Transfer or REST also uses web standards, but the exchange of data between the two endpoints could be either XML or increasingly using JSON as the format.
The REST way of interoperability is simpler compared to SOAP and hence, REST has found a lot wider deployment in the web services world.
Typically, client-server communication is facilitated using REST where the server supports a REST API and the client can then invoke the REST API endpoints in order to obtain information or to upload information to the server.
Within Representational State Transfer, there are four basic design principles:
1. First and foremost, REST is built upon HTTP protocol, so it uses all the HTTP methods.
2. Second, REST is designed to be stateless, meaning that the server doesn't store any information about the state after the communication is completed.
3. Third, the REST way of providing resources is to expose a directory structure like URLs (Uniform Resource Locators - URLs).
4. Fourth, the format for data exchange is typically JSON or XML or both can be supported using REST.
In the REST world you often hear people talking about nouns, verbs, and representations.
1. Nouns specifically refer to resources and these resources are usually identified by their URLs and these are unconstrained.
  Now, these resources can be organized into a hierarchy of the specification of this URI.
  So, as we traverse the path, we go from the more general to the more specific of the resource.
  This directory structure enables you to identify the resources that you use or provide from your server-side very easily.
2. Verbs are constraint and these specify the actions to be done on the resources.
   GET, POST, PUT and DELETE, are mapped into the four CRUD operations that we can carry out on a database that stores these resources on the server-side,
   the READ, CREATE, UPDATE, and DELETE operations.
3. Representsation is, when the information needs to be conveyed from the server to the client or from the client to the server, how you encode the information.
  Typically, either using JSON or using XML.

DELETE operation would be idempotent because if you try to delete a resource and the resource exists, it will be deleted.
If you are trying to delete a non-existing resource, it won't cause any further modification to the server-side, except that the server will reply with an error saying that the resource doesn't exist.
Similarly, the GET operation is also an idempotent operation because it is not making any modifications to the resource on the server-side.
POST and PUT of course are going to modify the resource on the server-side, either create a new resource or modify an existing resource on the server-side.
Each endpoint is identified by a URI, and we can specify the various operations to be done on each endpoint using the appropriate HTTP verb, the GET, PUT, POST, or DELETE.
The last part that we need to emphasize is that server-side should be completely stateless,
which means that the server-side does not track the client state because if the server needs to track the clients state, it will not be scalable.
So, for a scalable implementation of the server-side, you normally use a stateless server on the server-side.
So, every request that the client sends to the server will be treated as an independent request and will not reflect upon previous requests that have already been handled by the server from that particular client.
So, it's the responsibility of the client to track its own state, either in the form of using cookies or using a client-side database, whatever means that is suitable.
Now, this approach where the client tracks its own state is a lot more scalable because each individual client will be responsible for tracking its own state.
This is where the client-side MVC setup helps us in this regard.

EXPRESS ROUTER:
If you are implementing an Express application which supports multiple REST API endpoints,
then it makes sense to subdivide the code into multiple modules and then make use of them to construct the overall Express application.
So this where the Express router comes to our aid.
Express router enables us to subdivide our application and organize it into multiple mini Express-like applications, which combine together to form the Express application.
An Express router defines many Express application, and within that many Express application,
you can, for example, deal with one particular REST API endpoint in more detail, or one particular pattern of REST API endpoint in more detail.

Exercise (Instructions): Express Router:
In this exercise, we used the Express framework and Express router to build a server supporting a REST API.

Setting up a REST API:
1.You will continue in the node-express folder and modify the server in this exercise.
2.Install body-parser by typing the following at the command prompt:
     npm install body-parser@1.18.3 --save
3.Update index.js to add /dishes and /dishes:dishId REST api endpoints.
4.Start the server and interact with it from the browser/postman.
5.Do a Git commit with the message "Express Simple REST Api".

Using Express Router:
1.Create a new folder named routes in the node-express folder.
2.Create a new file named dishRouter.js in the routes folder and add the code to implement /dishes route.
3.Update index.js to use dishesRouter module within the main express app.
4.Start the server and interact with it and see the result.
5.Do a Git commit with the message "Express Router".

