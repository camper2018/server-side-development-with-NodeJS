JavaScript, when it is first designed was meant to be a scripting language to be used within the browser.
Now JavaScript has gone way beyond its original intention, and is being used for writing applications, both to be run using frameworks within the browser,
and also to run applications on the server side.
JavaScript originally was never designed with any common libraries.
If you look at standard programming languages like C, C++, Java, and so on,
they all have standard libraries that enable you to access the underlying hardware.
And also provide a structured way of organization the application into multiple files and then combining them together when you create an application.
JavaScript never had any of this support when it began.
But of course, people understood the difficulties when you need to expand JavaScript beyond a single file which is used as a scripting language for the browser.
Now, if you have a very large JavaScript application, it becomes cumbersome to write the entire code in one single file.
And obviously you want the results to be able to break your application into multiple facts.
Unlike traditional programming languages, JavaScript never had a way of distributing the code into multiple files and then combining them together.
So this is where the CommonJS API came in to fill in this gap that fills in the needs for some common application.
And this CommonJS format defines a module format that can be used for breaking up your JavaScript application into multiple files.
Node adopts that CommonJS format for organizing our JavaScript application into multiple files.
And within JavaScript, with the CommonJS format, each file becomes its own Node module.
So within that file, the CommonJS specification provides a variable called the module variable which is a JavaScript object.
And this gives you access to the current module definition within a file.
And on this module object, you have the module.exports property which determines the export from the current module.
So when you assign something to the module.exports property, then that becomes the exported value from the current module.
So that when this module is imported into another file of our Node application, then whatever is exported from this module becomes available in the second application.
When you need to import a module into another module, this is where the require function is used to import the module.
Node modules can be of three kinds:
1. We have file-based Node modules where we define the Node module within a file, within our application and we make use of it within our application.
2. We have core Node modules that are already part of Node.
The Node designers kept these core modules intentionally small so that Node can be kept small.
And also provide sufficient functionality so that external module designers can add in their own functionality that can be leveraged when we developed Node applications.
So the core modules include path, file system (fs), os, util, and a few others.
3. Then we have external Node modules.
These are third-party Node modules that are developed by Node developers, and then made available through the Node ecosystem.
So these external Node modules can be install within our system using NPM.

Package.json is a Menifest file for our app. It is a file that contains information about the files in our app i.e metadata eg: name, version, liscence, author, modules used etc
With node, we have the option of using JavaScript or Typescript as a language.
The documentation for node and also express, all use standard JavaScript as a default. So we will be using standard JavaScript in this course or ES2015 JavaScript in this course.
If we prefer to use TypeScript, we can set up our node examples to write our application in TypeScript.
But then we will have to transpile that code into JavaScript so that it can be run using Node.
So we have to set up additional infrastructure in order to be able to use TypeScript.
Asynchronous execution and Callbacks:
Before we proceed on to talk about Node Modules and Callbacks, we need to understand two salient features about the JavaScript language itself.
First and foremost, JavaScript supports what is called as first-class functions.
Is that a function can be treated just like any other variable.
And hence, functions can be passed around as parameters inside function calls to other functions.
And that essentially allows us to send in functions as callback functions that can be called from another Node module in order to get some work accomplished.
Then look at how this is very useful in supporting callbacks in Node.js
The second aspect about JavaScript is the support for Closures.
A function defined inside another function automatically gets access to the variables that are declared in the outer function. So even if the outer function is completed execution, when the inner function executes later the inner function will still have access to the values of the variables within that outer function.
And this is again, very effectively used when we use Callbacks in Node applications.

HTTP VERBS:
Http is a client-server communication protocol.
Get, Post, Put, Delete, Head, Options, Trace, Connect.

Intro To Express:
The Node designers intentionally kept node small with a small number of code modules so that they can leave it up to third party developers to come up with innovative solutions to problems.
One of the most popular third party Node modules or frameworks for building HTTP servers is Express.
Express is a fast, unopinionated, minimalist framework that runs on top of Node.js and supports Web development.
Express also provides a way of extending and adding functionality to Express through third-party middleware.
To use Express in your project, of course, the first step is to install Express and since Express is a Node module, we install it by saying npm install express --save and this would install Express into your local project.
The middleware that Express supports provide a lot of plug-in functionality that would be used to enhance your Express application,
plug-in functionality like for example we will look at a middleware called Morgan which allows you to print out log information to the screen about the requests that come into your server.
Similarly, we'll look at another middleware called BodyParser, which allows you to parse the body of the incoming HTTP request message and extract information from it for use within your Express application.
Similarly, they can serve up static Web resources from our server using the express.static so this will serve up information from a folder within our Express project,
and in declaring the project we can say __filename and __dirname which gives you the full path for the file or the directory for the current module.
Brief Tour of a Node Module:
Examine a Package.json file and look at semantic versioning.
So when you specify the version of the package that you use, you always specify the version by specifying the Major Version.Minor Version.the patch.
So when you install a package, it is always identified by these three numbers:
major version which might introduce breaking changes so which means that if you are installing a newer version of package it may not be completely backward compatible with previous versions.
It may introduce breaking changes whereby you may need to go back and fix the code that you might have written in the earlier version of your project.
The minor version introduces some minor changes to your package and may not be breaking changes.
A patch would be a bug fix that is often issued when a small bug is discovered.
So patches usually do not lead to any breaking changes and so you can easily use a higher version or a higher patch version of a particular package that you're using within your Node application.
With npm install, we can specifiy the acceptable package version as follows:
1.Exact: means exact version match : npm install express@4.0.0
2.Patch acceptable: npm install express@"~4.0.0"
3.Minor version acceptable:npm install express@"^4.0.0"
This kind of information is also saved in the package.json file.
The third-party modules and their version info is stored in package.json file in as dependencies.

Package.lock.json file:
This is being installed by the newer versions of npm.
The package-lock.json file is automatically generated by npm which stores information about the exact tree that was generated when you install other Node modules
and this is very useful when you need to do installation of the Node modules at another location.
So for example if you download a Git repository and try to recreate this project on another computer, you would simply type npm install on the prompt and that'll prompt your Node application to automatically install everything that is specified in the dependencies here for you.
While creating that the package-lock.json stores additional information that is used by npm to do the correct installation of all the npm modules that are required.

Exercise (Instructions): Introduction to Express:
In this exercise you learnt to use the Express framework to design and implement a web server.
a.A Simple Server using Express:
1.Create a folder named node-express in the NodeJS folder and move to that folder.
2.Copy the public folder from node-http to this folder.
3.At the prompt, type the following to initialize a package.json file in the node-express folder:
npm init
4.Accept the standard defaults suggested until you end up with a package.json file as we have in folder.
5.Then, install the Express framework in the folder by typing the following at the prompt:
  npm install express@4.16.3 --save
6.Create a file named .gitignore and add the following to it:
  node_modules
7.Create a file named index.js and add the code to it as seen in commit "Express Example".
8.Start the server by typing the following at the prompt, and then interact with the server:
  npm start
9.Initialize a Git repository, add the files and do a Git commit with the message "Express Example".

b.Serving Static Files:
1.Install morgan by typing the following at the prompt. Morgan is used for logging purposes:
  npm install morgan@1.9.0 --save
2.Update index.js to include it.
3.Start the server and interact with it and observe the behavior.
4.Do a Git commit with the message "Express Serve Static Files".
